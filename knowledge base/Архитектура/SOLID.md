#### Single Responsibility Principle / Принцип единственной ответственности

_1 сущность должна решать одну задачу._

![](https://telegra.ph/file/08c22ab252e2ea78ffc85.png)

Если сущность отвечает за несколько областей, то растет связность кода, а с ней и вероятность багов. Лучше разбить сущность на несколько, чтобы повысить читаемость, тестируемой и поддерживаемость.

**Например**, если класс Person содержит данные о пользователе и методы создания/редактирования/удаления/запросы пользователя в БД, то это божественный объект. Нужно вынести эти методы в отдельный класс - PersonService или PersonRepository. Если требуется логирование, то создать Logger и .т.д. Упарываться не стоит (не стоит делать GetPersionService и т.д.).

**Для компонентов:** есть форма, которая валидирует реквизиты. Нужно добавить туда и валидацию зарубежных реквизитов. Надо обобщить эту форму и в неё передавать onSubmit. Тогда можно создать две формы RussianRequisites, ForeingRequisites со своей логикой сохранения и валидации. Дальше создать CreateRequisitesForm и по пропсу isForeign выбирать что отрисовать: RussianRequisites или ForeingRequisites.
  

#### Open-Closed Principle / Принцип открытости закрытости

_Программные сущности должны быть открыты для расширения, но закрыты для изменения._ 

![](https://telegra.ph/file/6092d4f48bd39ad35b3c6.png)

Добавлять новые функционал стоит не через изменение родственных сущностей, а через создание новой сущности. Это повысит надежность кода, т.к. будет при изменении будет затрагиваться меньшая область работы.

**Например**, не стоит менять методы класса, у лучше создавать новые методы с нужной функциональностью.

**Для компонентов:** если в иностранную форму нужно добавить ещё поля, то не расширяем её функционал, а создаем компонент-обертку с этим функционалом.


#### Liskov Substitution Principle / Принцип подстановки Лисков

_Наследуемый класс должен дополнять, а не замещать поведение базового класса._

![](https://telegra.ph/file/907281c83ccc907e7fb8b.png)

Если тип П является подтипом Т, то любой объект типа Т можно заменить объектом типа П без ущерба функциональности программы. Методы и свойства каждого из классов П не должны привносить неожиданностей.

**Например**, класс Developer с методом writeCode. Если создадим классы MobileDeveloper, у которого не должно быть метода writeCode и будет возвращать null - это нарушить LSP.

**Для компонентов:** если в форму для реквизитов требуется добавить паспортные данные, то следует создавать компонент PassportData и потом ещё одну форму FullRequisitesForm. Такая декомпозиция дополнит базовый класс, но не заместит его полностью, что повысит надежность системы.
  

#### Interface Segregation Principle / Принцип разделения интерфейса

_Программные сущности не должны зависеть от методов, которые они не используют._

![](https://telegra.ph/file/41019cd76c6838665ed90.png)

Следует разбивать толстые сущности на более узкоспециализированные, чтобы не было случаев, когда какой-то метод класса должен быть реализован, но по факту он не нужен и заполнять его нечем. Сущности должны производить только те операции, которые необходимы для осуществления их деятельности.
Принцип тесно переплетается с SRP и LSP.

**Например**, MobileDeveloper реализуется метод, которым он не пользуется (writeCode). Поэтому выше по цепочке наследования следует провести декомпозицию.


#### Dependency Inversion Principle / Принцип инверсии зависимостей

- _A. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций._
- _B. Абстракции не должны зависеть от деталей, но детали должны зависеть от абстракций._

![](https://telegra.ph/file/54d511e3f64394050ab9c.png)

Модули верхнего уровня - это классы, которые выполняют операции при помощи инструмента.  
Модули нижнего уровня - это инструменты, которые нужны для выполнения операций.  
Абстракции - интерфейс, который соединяет два класса. Детали - специфические особенности инструментов.

Согласно этому принципу, **класс не должен соединяться с инструментом напрямую, а должен работать через интерфейс-абстракцию, которые соединяет эти два модуля.**  
Кроме того, **ни интерфейс, ни класс не должны вникать в специфику работы инструмента.**
  
**Например**, детали в одинаковых станках должны быть одинаковыми. Если при замене детали станок начнет работать по-другому и рабочие не смогут на нем работать или если детали будет требоваться другое напряжение в сети, то работа завода будет нарушена. Нужно вводит прокладки: для электричества - трансформатор, для рабочих пульт управления.

Допустим, если три хранилища не связанных наследование: для excel, для mongodb, для dictionary, для json. Все они реализуют методы CRUD. Стоит ввести абстрактный класс Storage с этими методами, эти хранилища наследовать от Storage и везде полагаться на Storage. Таким образом, удастся уйти от того деталей более высокие уровень (например, работа со списком) не будет зависеть от более низкого уровня (способ обработки данных).

  

Источники:

[youtube](https://www.youtube.com/watch?v=TxZwqVTaCmA&ab_channel=UlbiTV) 
[habr](https://habr.com/ru/company/productivity_inside/blog/505430/)
