## Цель

Основной целью React Fiber было создание **инкрементального рендеринга**. С ним можно делить работу на части и распределять выполнение по нужным временным интервалам.

Поэтому стало возможно следующее:

- приостановка и продолжение работ,
- приоритизация работ,
- планирование работ,
- переиспользование результатов выполненных ранее работ,
- отмена работ.

После процесса реконсиляции все работы собираются в стек, приоритизируются и выполняются. Если пользователь взаимодействует с приложением, его действия могут порождать новые работы после реконсиляции, которые благодаря планировщику будут выполнены вне очереди, так как имеют высший приоритет.

### Реконсиляция

**Реконсиляция в React — это процесс генерации минимального количества операций для перехода из одного дерева Fiber в другое.**

Подобные проблемы решались задолго до React, но подходящего алгоритма быстрее O(n$^3$) пока никто не открыл. Такая производительность не устраивала команду React, поэтому, вдохновившись существующими алгоритмами, они разработали свой эвристический алгоритм. Зная данные нод деревьев, они упростили некоторые сравнения, что дало на выходе O(n) в большинстве случаев. При сравнении Fiber есть два типа сравнения. О них далее.

### Сравнение элементов

ПС: В случаях, когда во время рендера меняется только определённое свойство внутри style элемента, это не вызывает полную регенерацию всех стилей, поэтому плохая производительность инлайн стилей — это миф. Единственная проблема производительности инлайн стилей — это создание нового анонимного объекта на каждом рендере.

### Сравнение списков

При сравнении списков проходит итерация по одному и тому же списку в деревьях, на каждом этапе сравниваются соответствующие индексу элементы. В случаях, когда мы пытаемся вставить один элемент и хотим оставить все остальные элементы без изменений, произойдёт полная замена всех элементов или их модификация, если типы при сравнении будут совпадать. Чтобы этого избежать, можно помочь React понять, какой элемент с каким сравнивать, передав уникальный ключ в каждый элемент —
`<div key={item.id}>{item.name}</div>`