## Доступ процессов к файлам и каталогам

Загрузка Linux начинается с того, что на всех терминалах запускается программа `getty`, в которую вводится логин и пароль. Эти данные `getty` передаёт программе `login`. Если логин подтверждает пользователя, то он запускает стартовый командный интерпретатор.

Выполняющиеся программы называются `процессом`. Каждый процесс регистрируется в таблице процессов. Каждый процесс имеет идентификатор `PID` (process identificator).
Посмотреть список своих процессов можно командой `ps` (process status).

Также у процесса есть `PPID` (parent `PID`), который также выводится в этом списке. Есть родительского процесса нет в списке, значит, он не принадлежит текущему пользователю.
Доступ к процессу регулируется с помощью идентификатора пользователя и идентификатора группы, которые система присваивает каждому процессу.

## Запуск дочерних процессов

Команда `exec` запускает новый процесс на месте родительского, а родительский удаляется из памяти. Старый процесс из памяти удаляется, а на его место ставится новый, даже `PID` остаётся тот же и то же окружение. Вернуться к старому процессу невозможно.

Команда `fork` создаёт ещё один процесс из родительского, но не удаляет его. Дочерний процесс имеет то же окружение, то же содержимое памяти и продолжает работу с той же точки. Но эти процессы имеют разные `PID` и разный возвращаемый результат команды `fork`.

Когда в интерпретаторе вызывается команда, то она вызывается с помощью команды `exec`. Пока дочерний процесс выполняется, родитель ждёт завершения работы с помощью команды `wait`. После завершения результат передаётся родителю и интерпретатор продолжается работу в родительском процессе.

Для того, чтобы запустить процесс через `exec` нужно вызвать его как `sh processName`, а через `fork` - как `sh processName&`.

Процесс запущенный через `exec` будет выполняться в текущем терминале и может получать данные с ввода терминала. Такой процесс называется активным. На каждом терминале может быть не более одного активного процесса.

Процесс запущенный через `fork` будет выполняться параллельно. Такой процесс называется фоновым. Он не имеет возможности вводить данные с терминала. Пользователь может создать сколько угодно фоновых процессов, но не более максимально возможного в системе.

Перевести последний фоновый процесс, запущенный через командную оболочку, в активный можно с помощью команды `fg` (foreground)


## Параллельность работы процессов

Параллельность работы в линуксе - дискретная. Это значить что в момент времени выполняется столько процессов, сколько центральных процессов есть в компьютере. Дав процессу немного поработать, система запоминает контекст этого процесса и загружает следующий процесс, из очереди процессов, а предыдущий помещается в конец очереди. Когда система вновь дойдёт до этого процесса, она вспомнит контекст процесса и продолжит выполнение с той точки, на которой остановилась.

Большинству процессов работать прямо сейчас не нужно. Они находятся в спячке и ожидают события, которое им нужно обработать. Например, процесс `bash` обычно спит в ожидании ввода с клавиатуры.

Посмотреть, как потребляются ресурсы системы процессами, можно с помощью команды `top`.


## Сигналы

`Сигнал` - короткое сообщение, посылаемое системой или процессом другому процессу.

Обрабатывается асинхронно специальной программой обработчиком. Если процесс не обрабатывает этот сигнал самостоятельно - это делает программа обработчик. Два сигнала `9` (KILL) и `10` (STOP) всегда обрабатываются системой. 

Сигнал стоп приостанавливает процесс. Продолжить его можно сигналом `18` (CONT).

В Linux сигнал стоп можно передать через `Ctrl + Z`.

Перевести последний остановленный процесс в фон можно с помощью команды `bg`.
Сделать последний процесс активным можно с помощью команды `fg`.

Убить процесс можно через команду `kill pid`.

Стартовый процесс, отец всех процессов, `init` имеет `pid = 1`. После того, как какой-то из процессов осиротел, он становится его родителем.


## Папки процессов в файловой системе

В линуксе почти всегда используется виртуальная файловая система `Procfs` - каталог `/proc`, в котором лежат подкаталоги процессов.

Имена подкаталогов совпадают с `PID` процесса. Хозяином такого подкаталога будет хозяин процесса. Поэтому любой пользователь в каждый момент времени может посмотреть все процессы, которыми он владеет. Утилита `ps` пользуется именно каталогом `proc`. Чтобы иметь доступ ко всем процессам нужно входить в группу пользователей `proc`.


## Подмена идентификатора пользователя

Запускаемый процесс получает UID пользователя, который его запустил. Поэтому процессы `su` и `sudo` не в состоянии изменить UID для процесса на 0. Тогда как пользователь получает доступ к суперпользовательскому интерпретатору? Должен существовать механизм, позволяющий запускать процессы от имени другого пользователя.

В линуксе этот механизм называется подменой идентификатора. Процесс может поменять свой UID, если запустит при помощи `exec` другую программу из файла, имеющего атрибут `SetUID`. В этом случае UID процесса становится равным UID файла, из которого программа была запущена.

Есть ещё атрибут `SetGID`. Он может присваиваться не только файлам, но и каталогам.

Строго говоря, изменяется не именно идентификатор пользователя, а исполнительный идентификатор пользователя `EUID`. Это нужно для того, чтобы точно знать, кто на самом деле запустил программу

Подмена идентификатора работает для программ, но не для сценариев (имеется ввиду повесить `SetUID` / `SetGID` на файл сценария). Это не работает так как в процессе запускается не сам файл, а интерпретатор, который уже выполняет команды из файла. Так что на атрибуты файла сценария ему всё равно.


## Интеграция процессов

После завершения работы процесс возвращает родительскому процессу число - статус завершения процесса. Если `0` - процесс завершился успешно. В противном случае число равно коду ошибки.

Статус последнего завершенного процесса хранится в переменной `? (echo $?)`.


## Исполняемые файлы и сценарии 

Исполняемые файлы является результатом компиляции программы. 

Если прочитать такой файл с помощью команды `cat`, то будет выведены разнообразные символы, в том числе управляющие. Они называются машинными кодами и нужны для передачи команд компьютеру.

`Сценарий` - это текстовый файл, предназначенный для обработки какой-нибудь утилитой. Чаще всего такая утилита - это какой-нибудь интерпретатор, а содержимое файла - это программа на языке этого интерпретатора.

В начале каждого сценария можно указать, какой именно интерпретатор использовать. Если он не задан, то по умолчанию используется `/bin/sh`.

Чтобы сделать файл сценария исполняемым, надо добавить вид доступа execute - `sh -x fileName`.

Чтобы запускать сценарий можно было без указания относительного пути, нужно добавить каталог, где расположен файл в `PATH`.


## Стартовые сценарии

При старте работы (при запуске стартового командного интерпретатора) выполняется сценарий из файла `/etc/profile`. Далее выполняются персональные сценарии из личной директории из файла `.profile`.