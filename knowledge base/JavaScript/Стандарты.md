За развитием стандарта можно следить на [GitHub](https://github.com/tc39/ecma262). 

Кратко об истории:

- ES1, ES2 — первые редакции,
- ES3 (1999) — `RegExp`, `try` и `catch`,
- ES4 — тёмные времена,
- ES5 (2009) — строгий режим, геттеры и сеттеры, нативная поддержка JSON, новые методы `Array` и `Object`.

##### ECMAScript 2015:

- классы,
- `let` и `const`,
- стрелочные функции,
- шаблонные строки,
- деструктуризация,
- `Promise`.

##### ECMAScript 2016:

- оператор ** (возведение в степень),
- `Array.prototype.includes`.

##### ECMAScript 2017:

- `async` / `await`,
- `Object.values`,
- `Object.entries`,
- `String.prototype.pad[Start|End]`.

##### ECMAScript 2018:

- `rest` и `spread` оператор массивов,
- `rest` и `spread` оператор объектов,
- `Promise.prototype.finally`.


## Варианты решения проблем

### Полифилы

Проблема: заново написать все стандарты и покрыть их тестами — это займёт много времени. И всё так же нет типов, придётся проверять их вручную.

На самом деле все полифилы давно написаны за нас, и можно их поставить из npm. Но если бездумно ставить полифилы — вес приложения может заметно вырасти.

  
### Транспиляция

С помощью специальных компиляторов можно преобразовывать современный код в более старый и поддерживаемый различными ранними версиями браузеров, набор которых можно указать при конфигурации.

Пример такого компилятора — Babel.


### Отдельные языки со своими компиляторами

Языки вроде Dart, CoffeeScript, Clojure и Elm в целом неплохие, но основная проблема — это не «родной» JavaScript. Читаемость кода упадёт, переключаться будет сложнее, всплывут вопросы с поддержкой и интеграцией, а зоопарк различного фронтенда будет только мешать. Даже с типизацией и многими крутыми вещами «из коробки».

### Типизированный JS

#### [Flowjs](https://flow.org/)

#### [TypeScript](https://www.typescriptlang.org/index.html)

  
  
  
**