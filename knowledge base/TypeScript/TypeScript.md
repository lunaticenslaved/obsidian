## Что это такое

**TypeScript** — это тот же JavaScript, а не другой язык программирования. Он обратно совместим с JavaScript — после компиляции разработчик получит обычный JS.

Преимущества языка:
- аннотации типов и проверка их согласования на этапе компиляции;
- интерфейсы, кортежи, декораторы свойств и методов, расширенные возможности ООП;
- широкая поддержка IDE и адекватный автокомплит;
- поддержка ES6-модулей из коробки;
- TypeScript — надмножество JavaScript, поэтому любой код на JavaScript будет выполнен и в TypeScript.


## Типы и особенности

##### Enum

Обратите внимание, что перечисления можно создавать двумя способами — enum и const enum.

В скомпилированном коде enum превратится в объект. А вот const enum не сгенерирует новый код, но полностью удалится во время компиляции, и в местах использования значений из такого «enum» будут подставлены соответствующие значения. Больше примеров с константными перечислениями найдёте [в документации](https://www.typescriptlang.org/docs/handbook/enums.html#const-enums).

##### Record

Иногда бывают задачи, где не важно знать о ключах объекта (например, они динамически добавляются и удаляются), но важно знать, что в значениях лежат только числа (например делаем счётчик чего-то). В таких случаях поможет тип Record:  
```
const counter: Record<string, number> = {
    apple: 1,
    orange: 8,
    banana: 6,
    grape: 5
};

const counter: { [key: string]: number } = {
    apple: 1,
    orange: 8,
    banana: 6,
    grape: 5
};  
```
Этот синтаксис стоит иметь в виду при работе с типами, но для продуктовых задач чаще хватает Record или явного описания объекта.


##### any

Вместо any по умолчанию старайтесь использовать тип `unknown`, потому что язык будет ругаться на него, если «почувствует» что-то некорректное.


##### unknown

Применять тип `unknown` можно следующим образом:
```
function isNumberArray(value: unknown): value is number[] {
    return (
        Array.isArray(value) &&
        value.every(element => typeof element === "number")
    );
} 
```

Конструкция `value is number[]` является защитником типа (`Type Guard`) и в данном случае говорит TS, что если функция вернёт `true`, то переданная переменная является массивом чисел, и после этого с переменной можно работать как с известным типом:

```
function processNumbers(value: unknown) {
	// Здесь TypeScript не позволит вызвать метод map, 
	// так как не знает, есть ли он у unknown value.map(e => e * 2);
	// Object is of type 'unknown'
	// Если type guard вернёт false — прекратим выполнение функции
	if (!isNumberArray(value)) {
	  return;
	}
	
	// Здесь TypeScript понимает, что если сюда добрались 
	// — значит, в value лежит массив чисел и всё будет работать
	value.map(e => e * 2);
} 
```


##### void и never

Типы `void` и `never` отличаются следующим:

- `void` говорит, что функция не возвращает никакого значения,
- `never` говорит, что функция в каком-то случае может никогда не закончиться и никогда не вернуть результат.


### Приведение типов

Типы можно «кастить», или приводить к другим типам:
```
const someValue: any = 'this is a string';

const strLength2: number = (someValue as string).length; 
```

Будьте осторожны с «кастингом» типов. Так вы говорите компилятору: «Здесь точно будет такой тип, доверься мне», а значит есть риск пропустить ошибку.

### Перегрузка функций и методов

```
function square(num: number): number;
function square(num: string): number;
function square(num: any): number {
  if (typeof num === 'string') {
    return parseInt(num, 10) * parseInt(num, 10);
  } else {
    return num * num;
  }
}
```

### Interface или Type

Что касается использования типов или интерфейсов — здесь пользователи TypeScript придерживаются позиции, что объекты лучше типизировать с помощью type. 

Во-первых, потому что эта запись имеет больше возможностей. Во-вторых, следуя логике из «взрослых» языков: интерфейс — это контракт поведения, и он должен использоваться вместе с ключевым словом `implements`, когда класс реализует интерфейс. Но опять же — вы должны сами для себя решить, как и что использовать, жёстких норм нет.

### Классы

#### Модификаторы доступов

У методов и свойств классов появились модификаторы доступов:
- `public` — доступны без ограничений, это значение по умолчанию;
- `private` — доступны только внутри класса;
- `protected` — доступны внутри класса и в классах-наследниках;
- `readonly` — комбинируется со всеми предыдущими, не даёт перезаписывать свойство. Оно должно быть или задано изначально, или задано в конструкторе.


### Абстрактные классы

#### Декораторы

// TODO

#### Дженерики

```
interface ISwim {
  swim()
}

class Dog implements ISwim {
  swim() { ... }
}

class Duck implements ISwim {
  swim() { ... }
}

function swimTogether<
  T1 implements ISwim,
  T2 implements ISwim
>(firstPal: T1, secondPal: T2) {
  firstPal.swim();
  secondPal.swim();
}
```


## Типизация JS-кода

`TypeScript Declaration Files (*.d.ts)` — это файлы для описания интерфейсов.

Основная проблема: не все JS-библиотеки имеют совместимость с TypeScript. И при использовании JS-файлов в TypeScript сталкиваемся с ошибками типизации, так как TypeScript не знает, что за функция, какие у неё свойства и функция ли это.

Для этого есть `.d.ts` файлы, в которых описываются только интерфейсы и API библиотеки. 

С помощью `.d.ts` можно описывать глобальные переменные окружения или инструменты, которые написали сами и хочется вынести в отдельную библиотеку или пакет.

Типизировать также можно с помощью JSDoc и TypeScript.
